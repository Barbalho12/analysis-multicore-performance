# Analysis multicore performance #

This project aims to analyze the performance of ALGORITHM in relation to CPU affinity. The tests will be done using the normal execution of the algorithm and the exercise limiting the amount of CPUs that the program will be able to use.

## Menu

1. Requirements for the analysis
2. Gnuplot Tutorial
> * Install gnuplot
> * Generating the graph
3. Results
4. Conclusion
5. Members

## 1. Requirements for the analysis

* Use a computer with some Linux distribution (We indicate Ubuntu).
* Install the following packages to update C ++.

```bash
sudo apt-get install gcc-5-multilib g++-5-multilib
```

* [Download](http://goo.gl/q8zaor) and install the Texas Instruments SDK and install using the following commands and advance all options by clicking "Next".

```bash
chmod +x nomedoarquivobaixado
./nomedoarquivobaixado
```

## 2. Gnuplot Tutorial 

Gnuplot is a software that prevents the creation of graphics (2D and 3D) for various environments (UNIX, Windows, Macintosh, etc). Here are some basic commands for using this tool.

### i. Install gnuplot 

```bash
sudo apt-get install gnuplot-x11
```

### ii. Generating the graph 

1. Access the directory containing the "clock.dat" and "time.dat" files (which were generated by the execution of the methods) and "grafico.gnu" (gnuplot execution script) by the terminal:

```bash
cd data
```

2. Type the command in the Terminal:

```bash
gnuplot grafico.gnu
```

To create the graphics just run the gnuplot using the gnuplot script of this project.

```bash
gnuplot performance.gnuplot
```

## 3. Results

Hardware Settings Used for Analyzes:

Settings:
- Intel Pentium G3250 3GHz x2
- 4 GB of RAM
- 64-bit
- Ubuntu

(IMPORTANT) In the graphs, in the axis of the "Analyzes" ignore the numbers 1,5 and 2,5, since they do not correspond to any analysis. The content was published this way because it was not possible to use bar charts.

The program ran alone on the computer. For each function 3 different analyzes were performed:

1. Run the function on a thread and just a core;
2. Run two instances of the same function on two threads and on different colors;
3. Run two instances of the same function on two threads and on the same core.

In this way we construct 3 Graphs, one for each function, in which the execution times are displayed
for each of the analyzes:

![f1](MulticorePerformance/dados-coletados/f1.png?raw=true "Análises da Função 1")

![f2](MulticorePerformance/dados-coletados/f2.png?raw=true "Análises da Função 2")

![f3](MulticorePerformance/dados-coletados/f3.png?raw=true "Análises da Função 3")

![log](log.png?raw=true "Log de Eventos")

## 4. Conclusion 

This work presented an analysis of the efficiency of the different possibilities of executing a program in multicore environments that the hardware offers. Analyzing the graphs of the time analysis of the functions, the execution of function 1 is the fastest in all the analyzes, which is expected since it is the simplest function. Function 2 is slower in the execution of the first analysis, having more than 2s of duration. In the second analysis we have that there is practically a tie between functions 2 and 3 with approximately 2.5s of duration. In the third analysis the function 3 is faster than the function 2 with a difference of approximately 0.2s.

As we can see in the graphs, when using two cores running two instances of the same function, each in a thread, the execution time is halved, compared to execution in a single core. In this way, we notice how important it is in the development of software systems, knowledge about the machine's hardware capacity, and application of distributed programming concepts.

## 5. Members 

* Breno Maurício de Freitas Viana
* Felipe Barbalho Rocha

